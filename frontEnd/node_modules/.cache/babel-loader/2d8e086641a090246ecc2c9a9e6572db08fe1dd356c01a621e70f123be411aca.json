{"ast":null,"code":"import { createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \"vue\";\nconst _withScopeId = n => (_pushScopeId(\"data-v-6f26a9d6\"), n = n(), _popScopeId(), n);\nconst _hoisted_1 = {\n  class: \"container1\",\n  id: \"view1\"\n};\nconst _hoisted_2 = /*#__PURE__*/_withScopeId(() => /*#__PURE__*/_createElementVNode(\"svg\", {\n  width: \"100%\",\n  height: \"100%\"\n}, null, -1 /* HOISTED */));\nconst _hoisted_3 = [_hoisted_2];\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, _hoisted_3);\n}","map":{"version":3,"names":["class","id","_createElementVNode","width","height","_hoisted_2","_createElementBlock","_hoisted_1","_hoisted_3"],"sources":["/Users/younggaming/Documents/webstorm/ybcprogram/src/components/view11.vue"],"sourcesContent":["<template>\n  <div class=\"container1\" id=\"view1\">\n    <svg width=\"100%\" height=\"100%\"></svg>\n  </div>\n</template>\n\n<script>\nimport axisJson from '../../../../pyCharm/ybcProject/data/axis.json'\nimport corrDetailJson from '../../../../pyCharm/ybcProject/data/corr_detail.json'\nimport paraDetailJson from '../../../../pyCharm/ybcProject/data/para_detail.json'\nimport * as d3 from 'd3'\nexport default {\n  name: 'view1_1',\n  props: {\n    mainNum: Number,\n    corCop: Number,\n    k: Number\n  },\n  data () {\n    return {\n      chartConfig: {\n        axis: { width: 40, height: 90 },\n        axisMargin: { left: 118, top: 10 },\n        lineColor: ['#C8C8FF', '#C8FFC8', '#FFC8C8', '#FFFFC8', '#FFC8FF'],\n        highLightColor: ['#0000C8', '#00C800', '#C80000', '#C80000', '#C800C8']\n        // lineColor: ['#fef0d9', '#fdcc8a', '#fc8d59', '#e34a33', '#b30000']\n      },\n      chartValue: {\n        axisValue: ['4', '9', '16', '21', '25', '28', '31'],\n        copData: [4, 9, 16, 21, 25, 28, 31]\n      }\n    }\n  },\n  methods: {\n    creatPCchart () {\n      const that = this\n      const main = d3.select('#view1 svg')\n        .append('g')\n        .classed('main', true)\n        // 可以这么写数据，圆中心位置\n        .attr('transform', 'translate(' + 50 + ',' + 0 + ')')\n\n      // 画坐标轴\n      const axisData = that.getAxisData(axisJson)\n      const axiss = main.append('g')\n        .classed('axiss', true)\n      axiss.selectAll('g')\n        .data(axisData.axisPosition)\n        .enter()\n        .append('g')\n        .attr('class', function (d, i) {\n          return 'axis' + (i + 1)\n        })\n      for (let i = 0; i < axisData.axisPosition.length; i++) {\n        const axis = axiss.select('.axis' + (i + 1))\n        axis.append('rect')\n          .attr('x', axisData.axisPosition[i].x)\n          .attr('y', axisData.axisPosition[i].y)\n          .attr('width', that.chartConfig.axis.width)\n          .attr('height', that.chartConfig.axis.height)\n          .attr('fill', 'none')\n          .attr('stroke-width', 2)\n          .attr('stroke', 'black')\n      }\n\n      // 画线\n      const markData = that.getMarkData(axisData.axissValue, paraDetailJson)\n      const lines = main.append('g')\n        .classed('lines', true)\n      lines.selectAll('g')\n        .data(markData.line)\n        .enter()\n        .append('g')\n        .attr('class', function (d, i) {\n          return 'line' + (i + 1)\n        })\n      for (let i = 0; i < markData.line.length; i++) {\n        let lineGanerator = lines.select('.line' + (i + 1))\n        lineGanerator = d3.line() // .curve(d3.curveCatmullRom)\n        const linePath = lineGanerator(markData.line[i].copData)\n        main.append('path')\n          .attr('d', linePath)\n          .attr('fill', 'none')\n          .attr('stroke-width', 0.5)\n          .attr('stroke', markData.line[i].copColor)\n      }\n      const lineData = that.getLineData(axisData.axissValue, corrDetailJson)\n      const copLine = d3.line() // .curve(d3.curveCatmullRom)\n      const copPath = copLine(lineData[0]) // 如果是0的话将来要不改数据传输回来的形式要不前面加判断\n      main.append('path')\n        .attr('d', copPath)\n        .attr('fill', 'none')\n        .attr('stroke-width', 4)\n        .attr('stroke', '#0081C9')\n      const copCorLine = d3.line() // .curve(d3.curveCatmullRom)\n      const copCorPath = copCorLine(lineData[that.corCop]) // 如果是0的话将来要不改数据传输回来的形式要不前面加判断\n      main.append('path')\n        .attr('d', copCorPath)\n        .attr('fill', 'none')\n        .attr('stroke-width', 4)\n        .attr('stroke', '#54B435')\n    },\n\n    getMarkData (axis, cop) {\n      const keys = Object.keys(cop)\n      const data = []\n      const mark = []\n      for (let i = 0; i < keys.length; i++) {\n        const copData = []\n        let copColor = ''\n        for (let j = 0; j < 7; j++) {\n          const key = Object.keys(axis[j])\n          for (let k = 0; k < axis[j][key[0]].length; k++) {\n            if (Number(cop[keys[i]][j]) <= axis[j][key[0]][k].max && Number(cop[keys[i]][j]) >= axis[j][key[0]][k].min) {\n              if (j === this.mainNum) {\n                copColor = this.chartConfig.lineColor[k]\n              }\n              copData.push([j * (this.chartConfig.axis.width + this.chartConfig.axisMargin.left), (4 - k) * (this.chartConfig.axis.height + this.chartConfig.axisMargin.top) + this.chartConfig.axis.height * (axis[j][key[0]][k].max - Number(cop[keys[i]][j])) / (axis[j][key[0]][k].max - axis[j][key[0]][k].min) - (5 - this.k) * (this.chartConfig.axis.height + this.chartConfig.axisMargin.top)])\n              copData.push([j * (this.chartConfig.axis.width + this.chartConfig.axisMargin.left) + this.chartConfig.axis.width, (4 - k) * (this.chartConfig.axis.height + this.chartConfig.axisMargin.top) + this.chartConfig.axis.height * (axis[j][key[0]][k].max - Number(cop[keys[i]][j])) / (axis[j][key[0]][k].max - axis[j][key[0]][k].min) - (5 - this.k) * (this.chartConfig.axis.height + this.chartConfig.axisMargin.top)])\n              mark.push([j * (this.chartConfig.axis.width + this.chartConfig.axisMargin.left), (4 - k) * (this.chartConfig.axis.height + this.chartConfig.axisMargin.top) + this.chartConfig.axis.height * (axis[j][key[0]][k].max - Number(cop[keys[i]][j])) / (axis[j][key[0]][k].max - axis[j][key[0]][k].min) - (5 - this.k) * (this.chartConfig.axis.height + this.chartConfig.axisMargin.top)])\n              break\n            }\n          }\n        }\n        data.push({\n          copData: copData,\n          copColor: copColor\n        })\n      }\n      return { line: data, mark: mark }\n    },\n\n    getLineData (axis, cop) {\n      const keys = Object.keys(cop)\n      const data = []\n      for (let i = 0; i < keys.length; i++) {\n        const point = []\n        for (let j = 0; j < 7; j++) {\n          const key = Object.keys(axis[j])\n          for (let k = 0; k < axis[j][key[0]].length; k++) {\n            if (Number(cop[keys[i]][this.chartValue.copData[j]]) <= axis[j][key[0]][k].max && Number(cop[keys[i]][this.chartValue.copData[j]]) >= axis[j][key[0]][k].min) {\n              point.push([j * (this.chartConfig.axis.width + this.chartConfig.axisMargin.left), (4 - k) * (this.chartConfig.axis.height + this.chartConfig.axisMargin.top) + this.chartConfig.axis.height * (axis[j][key[0]][k].max - Number(cop[keys[i]][this.chartValue.copData[j]])) / (axis[j][key[0]][k].max - axis[j][key[0]][k].min) - (5 - this.k) * (this.chartConfig.axis.height + this.chartConfig.axisMargin.top)])\n              point.push([j * (this.chartConfig.axis.width + this.chartConfig.axisMargin.left) + this.chartConfig.axis.width, (4 - k) * (this.chartConfig.axis.height + this.chartConfig.axisMargin.top) + this.chartConfig.axis.height * (axis[j][key[0]][k].max - Number(cop[keys[i]][this.chartValue.copData[j]])) / (axis[j][key[0]][k].max - axis[j][key[0]][k].min) - (5 - this.k) * (this.chartConfig.axis.height + this.chartConfig.axisMargin.top)])\n              break\n            }\n          }\n        }\n        data.push(point)\n      }\n      return data\n    },\n\n    getAxisData (file) {\n      const keys = Object.keys(file)\n      let pos = 0\n      const axissValue = []\n      const axisPosition = []\n      for (let i = 0; i < keys.length; i++) {\n        const axisValue = []\n        if (keys[i] === this.chartValue.axisValue[pos]) {\n          for (let k = 0; k < file[keys[i]].length; k++) {\n            const key1 = Object.keys(file[keys[i]][k])\n            const min = file[keys[i]][k][key1[0]][0][0]\n            const max = file[keys[i]][k][key1[0]][0][1]\n            axisValue.push({\n              min: min,\n              max: max\n            })\n            axisPosition.push({\n              x: (this.chartConfig.axis.width + this.chartConfig.axisMargin.left) * pos,\n              y: (this.chartConfig.axis.height + this.chartConfig.axisMargin.top) * k\n            })\n          }\n          axissValue.push({\n            axis: axisValue,\n            key: keys[i]\n          })\n          pos += 1\n        }\n      }\n      // 交换axiss第3个与第4个元素\n      axissValue.splice(2, 1, ...axissValue.splice(3, 1, axissValue[2]))\n      const axis = {\n        axissValue: axissValue,\n        axisPosition: axisPosition\n      }\n      return axis\n    }\n  },\n  mounted () {\n    this.creatPCchart()\n  }\n}\n</script>\n\n<style scoped>\n\n.container1 {\n  width: 100%;\n  height: 100%;\n  /*border: 2px solid black;*/\n}\n\n</style>\n"],"mappings":";;;EACOA,KAAK,EAAC,YAAY;EAACC,EAAE,EAAC;;gEACzBC,mBAAA,CAAsC;EAAjCC,KAAK,EAAC,MAAM;EAACC,MAAM,EAAC;;oBAAzBC,UAAsC,C;;uBADxCC,mBAAA,CAEM,OAFNC,UAEM,EAAAC,UAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}
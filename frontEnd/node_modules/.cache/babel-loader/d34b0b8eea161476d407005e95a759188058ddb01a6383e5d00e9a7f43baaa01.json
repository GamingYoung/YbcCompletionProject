{"ast":null,"code":"import { createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \"vue\";\nconst _withScopeId = n => (_pushScopeId(\"data-v-172536cf\"), n = n(), _popScopeId(), n);\nconst _hoisted_1 = {\n  class: \"container\"\n};\nconst _hoisted_2 = /*#__PURE__*/_withScopeId(() => /*#__PURE__*/_createElementVNode(\"svg\", {\n  width: \"100%\",\n  height: \"100%\"\n}, null, -1 /* HOISTED */));\nconst _hoisted_3 = [_hoisted_2];\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, _hoisted_3);\n}","map":{"version":3,"names":["class","_createElementVNode","width","height","_hoisted_2","_createElementBlock","_hoisted_1","_hoisted_3"],"sources":["/Users/younggaming/Documents/webstorm/ybcprogram/src/components/view4.vue"],"sourcesContent":["<template>\n  <div class=\"container\">\n    <svg width=\"100%\" height=\"100%\"></svg>\n  </div>\n</template>\n\n<script>\nimport corrInd from '../../../../pyCharm/ybcProject/data/corr_ind.json'\nimport industryRatioJson from '../../../../pyCharm/ybcProject/data/ind_ratio_obj.json'\nimport industryLineJson from '../../../../pyCharm/ybcProject/data/ind_line_obj.json'\nimport copJson from '../../../../pyCharm/ybcProject/data/ind_copp.json'\nimport ringJson from '../../../../pyCharm/ybcProject/data/ring_obj.json'\nimport * as d3 from 'd3'\nexport default {\n  name: 'view_4',\n  data () {\n    return {\n      chartValue: {\n        targetInd: '',\n        correlation: [['', ''], ['', ''], ['', ''], ['', ''], ['', '']]\n      },\n      chartConfig: {\n        monthColor: ['#C5E0B4', '#F8CBAD', '#FFE699', '#E7E6E6'],\n        monthRectWidth: 100,\n        monthRectHeight: 20,\n        circleMinRadius: 5,\n        circleMaxRadius: 15,\n        ringMinRadius: 20,\n        ringMaxRadius: 30,\n        lineRadius: 40\n      }\n    }\n  },\n  computed: {\n    // 计算下面坐标轴长度，逻辑将来在写\n    axisLength: function () {\n      return 4\n    }\n  },\n  methods: {\n    // 根据比例获取响应颜色\n    getColor (proportion) {\n      const palette = [\n        ['#820000', '#FF8282'],\n        ['#008200', '#82FF82']\n      ]\n      if (proportion === 0) return '#0000FF'\n      const idx = proportion > 0 ? 0 : 1\n      const i = d3.interpolateLab(palette[idx][1], palette[idx][0])\n      return i(proportion)\n    },\n\n    getColor1 (proportion) {\n      const palette = ['#008200', '#60E260']\n      const i = d3.interpolateLab(palette[1], palette[0])\n      return i(proportion)\n    },\n\n    // 画图\n    creatLineChart () {\n      const that = this\n      const keys = Object.keys(industryRatioJson)\n      const main = d3.select('.container svg')\n        .append('g')\n        .classed('main', true)\n        .attr('transform', 'translate(' + 0 + ',' + 0 + ')')\n\n      // 画彩色坐标轴\n      const rectAxiss = main.append('g')\n        .classed('sectors', true)\n      rectAxiss.selectAll('g')\n        .data(industryRatioJson[keys[0]] + industryRatioJson[keys[1]])\n        .enter()\n        .append('g')\n        .attr('class', function (d, i) {\n          return 'rectAxis' + (i + 1)\n        })\n      for (let i = 0; i < industryRatioJson[keys[0]].length + industryRatioJson[keys[1]].length; i++) {\n        const rectAxis = rectAxiss.select('.rectAxis' + (i + 1))\n        if (i < industryRatioJson[keys[0]].length) {\n          rectAxis.append('rect')\n            .attr('x', i * that.chartConfig.monthRectWidth + 5 * i)\n            .attr('y', 0)\n            .attr('width', that.chartConfig.monthRectWidth)\n            .attr('height', that.chartConfig.monthRectHeight)\n            .attr('fill', that.chartConfig.monthColor[i % 4])\n        } else {\n          rectAxis.append('rect')\n            .attr('x', (i - industryRatioJson[keys[0]].length) * that.chartConfig.monthRectWidth + 5 * (i - 12))\n            .attr('y', 580)\n            .attr('width', that.chartConfig.monthRectWidth)\n            .attr('height', that.chartConfig.monthRectHeight)\n            .attr('fill', that.chartConfig.monthColor[(i - industryRatioJson[keys[0]].length) % 4])\n        }\n      }\n\n      // 画中间虚线\n      const axis = main.append('line')\n        .classed('axis', true)\n      axis.attr('x1', 0)\n        .attr('y1', 299)\n        .attr('x2', 1790)\n        .attr('y2', 299)\n        .attr('stroke-width', 2)\n        .attr('stroke', 'black')\n        .style('stroke-dasharray', '5.5')\n\n      const linesPoints = this.getLineData(industryRatioJson, industryLineJson, copJson)\n      console.log(linesPoints)\n      // 画圆环\n      const ringsData = that.getRingData(ringJson)\n      const views = main.append('g')\n        .classed('views', true)\n      views.selectAll('g')\n        .data(ringsData)\n        .enter()\n        .append('g')\n        .attr('class', function (d, i) {\n          return 'view' + (i + 1)\n        })\n      for (let k = 0; k < ringsData.length; k++) {\n        let view = views.select('.view' + (k + 1))\n        view = views.append('g').attr('transform', 'translate(' + 0 + ',' + 0 + ')')\n        const points = view.append('g')\n          .classed('points', true)\n        points.selectAll('g')\n          .data(ringsData[k])\n          .enter()\n          .append('g')\n          .attr('class', function (d, i) {\n            return 'point' + (i + 1)\n          })\n        const linesCircles = view.append('g')\n          .classed('linesCircles', true)\n        linesCircles.selectAll('g')\n          .data(ringsData[k])\n          .enter()\n          .append('g')\n          .attr('class', function (d, i) {\n            return 'linesCircle' + (i + 1)\n          })\n        const lineLines = view.append('g')\n          .classed('lineLines', true)\n        lineLines.selectAll('g')\n          .data(linesPoints[k])\n          .enter()\n          .append('g')\n          .attr('class', function (d, i) {\n            return 'lineLine' + (i + 1)\n          })\n        if (k === 1) {\n          const copLineLines = view.append('g')\n            .classed('copLineLines', true)\n          copLineLines.selectAll('g')\n            .data(linesPoints[2])\n            .enter()\n            .append('g')\n            .attr('class', function (d, i) {\n              return 'copLineLine' + (i + 1)\n            })\n        }\n        for (let i = 0; i < ringsData[k].length; i++) {\n          let point = points.select('.point' + (i + 1))\n          point = view.append('g').attr('transform', 'translate(' + linesPoints[k][i].x + ',' + linesPoints[k][i].y + ')')\n          const linesCircle = point.select('linesCircle' + (i + 1))\n          linesCircle.data(ringsData[k][i].linesColor)\n            .enter()\n            .append('g')\n            .attr('class', function (d, i) {\n              return 'lineCircle' + (i + 1)\n            })\n          // 画圆\n          const circle = point.append('circle')\n          circle.attr('cx', 0)\n            .attr('cy', 0)\n            .attr('r', ringsData[k][i].circleRadius)\n            .attr('fill', that.getColor1(linesPoints[k][i].proportion))\n          // 画环\n          const arcs = point.append('g')\n            .classed('arcs', true)\n          arcs.selectAll('g')\n            .data(ringsData[k][i].ringsWidth)\n            .enter()\n            .append('g')\n            .attr('class', function (d, i) {\n              return 'arc' + (i + 1)\n            })\n          for (let j = 0; j < ringsData[k][i].ringsWidth.length; j++) {\n            const defs = view.append('defs')\n            const linearGradient = defs.append('linearGradient')\n              .attr('id', 'linearColor' + i + '_' + j + '_' + k)\n              .attr('x1', '0%')\n              .attr('y1', '0%')\n              .attr('x2', '100%')\n              .attr('y2', '0%')\n            const stop1 = linearGradient.append('stop')\n              .attr('offset', '0%')\n            stop1.style('stop-color', ringsData[k][i].linesColor[j].head)\n            const stop2 = linearGradient.append('stop')\n              .attr('offset', '100%')\n            stop2.style('stop-color', ringsData[k][i].linesColor[j].rear)\n            let lineCircle = linesCircle.select('.lineCircle' + (j + 1))\n            lineCircle = d3.path()\n            lineCircle.arc(0, 0, that.chartConfig.lineRadius, -Math.PI / 2 + j * 2 * Math.PI / 5, -Math.PI / 2 + (j + 1) * 2 * Math.PI / 5 - 0.1)\n            point.append('path')\n              .attr('d', lineCircle.toString())\n              .style('fill', 'none')\n              .style('stroke', 'url(#' + linearGradient.attr('id') + ')')\n              .style('stroke-width', '2')\n            let arc = arcs.select('.arc' + (i + 1))\n            arc = d3.arc()\n              .outerRadius(ringsData[k][i].ringsWidth[j])\n              .innerRadius(that.chartConfig.ringMinRadius)\n              .startAngle(j * 2 * Math.PI / 5)\n              .endAngle((j + 1) * 2 * Math.PI / 5)\n            const outArc = point.append('path')\n              .attr('d', arc)\n            outArc.attr('fill', that.getColor(ringsData[k][i].ringsProportion[j]))\n          }\n          let lineLine = lineLines.select('lineLine' + (i + 1))\n          lineLine = point.append('line')\n            .attr('x1', 0)\n            .attr('y1', 0)\n            .attr('x2', that.chartConfig.lineRadius * Math.sin(linesPoints[k][i].angle))\n            .attr('y2', that.chartConfig.lineRadius * Math.cos(linesPoints[k][i].angle))\n            .attr('stroke-width', 1)\n          lineLine.attr('stroke', 'black').style('stroke-dasharray', '5.5')\n          if (k === 0) {\n            let copLineLine = lineLines.select('copLineLine' + (i + 1))\n            copLineLine = point.append('line')\n              .attr('x1', linesPoints[2][i].x - linesPoints[0][i].x)\n              .attr('y1', linesPoints[2][i].y - linesPoints[0][i].y)\n              .attr('x2', that.chartConfig.lineRadius * Math.sin(linesPoints[2][i].angle))\n              .attr('y2', that.chartConfig.lineRadius * Math.cos(linesPoints[2][i].angle))\n              .attr('stroke-width', 1)\n            copLineLine.attr('stroke', '#0081C9').style('stroke-dasharray', '5.5')\n          }\n        }\n      }\n\n      // 绘制折线图\n      const lines = main.append('g')\n      for (let j = 0; j < 2; j++) {\n        lines.selectAll('g')\n          .data(linesPoints[j])\n          .enter()\n          .append('g')\n          .attr('class', function (d, i) {\n            return 'line' + (i + 1)\n          })\n        for (let i = 0; i < linesPoints[j].length - 1; i++) {\n          const line = lines.select('.line' + (i + 1))\n          line.append('line')\n            .attr('x1', linesPoints[j][i].x)\n            .attr('y1', linesPoints[j][i].y)\n            .attr('x2', linesPoints[j][i + 1].x)\n            .attr('y2', linesPoints[j][i + 1].y)\n            .attr('stroke-width', 2)\n            .attr('stroke', 'black')\n        }\n      }\n      const copLines = main.append('g')\n      copLines.selectAll('g')\n        .data(linesPoints[2])\n        .enter()\n        .append('g')\n        .attr('class', function (d, i) {\n          return 'line' + (i + 1)\n        })\n      for (let i = 0; i < linesPoints[2].length - 1; i++) {\n        const line = copLines.select('.line' + (i + 1))\n        line.append('line')\n          .attr('x1', linesPoints[2][i].x)\n          .attr('y1', linesPoints[2][i].y)\n          .attr('x2', linesPoints[2][i + 1].x)\n          .attr('y2', linesPoints[2][i + 1].y)\n          .attr('stroke-width', 2)\n          .attr('stroke', '#0081C9')\n      }\n    },\n\n    // 将环图坐标返回\n    getRingData (file) {\n      const keyInd = Object.keys(file)\n      const ringsData = []\n      for (let i = 0; i < keyInd.length; i++) {\n        const keyMonth = Object.keys(file[keyInd[i]])\n        const copSum = []\n        let circleRadius = 0\n        const ringData = []\n        let ringMax = 0\n        for (let j = 0; j < keyMonth.length; j++) {\n          copSum[j] = 0\n          for (let k = 0; k < 5; k++) {\n            copSum[j] += file[keyInd[i]][keyMonth[j]][k][1]\n            ringMax = file[keyInd[i]][keyMonth[j]][k][1] > ringMax ? file[keyInd[i]][keyMonth[j]][k][1] : ringMax\n          }\n        }\n        const circleMin = Math.min.apply(null, copSum)\n        const circleMax = Math.max.apply(null, copSum)\n        for (let j = 0; j < keyMonth.length; j++) {\n          const ringsWidth = []\n          const ringsProportion = []\n          const lineColor = []\n          for (let k = 0; k < 5; k++) {\n            const ringWidth = this.chartConfig.ringMinRadius + file[keyInd[i]][keyMonth[j]][k][1] / ringMax * (this.chartConfig.ringMaxRadius - this.chartConfig.ringMinRadius)\n            let ringProportion = 0\n            if (j === 0) {\n              lineColor.push({\n                head: 'black',\n                rear: 'black'\n              })\n            } else {\n              ringProportion = (file[keyInd[i]][keyMonth[j]][k][1] - file[keyInd[i]][keyMonth[j - 1]][k][1]) / ringMax\n              lineColor.push({\n                head: file[keyInd[i]][keyMonth[j]][k][0][0] < file[keyInd[i]][keyMonth[j - 1]][k][0][0] ? 'red' : 'green',\n                rear: file[keyInd[i]][keyMonth[j]][k][0][1] < file[keyInd[i]][keyMonth[j - 1]][k][0][1] ? 'red' : 'green'\n              })\n            }\n            circleRadius = this.chartConfig.circleMinRadius + (copSum[j] - circleMin) / (circleMax - circleMin) * (this.chartConfig.circleMaxRadius - this.chartConfig.circleMinRadius)\n            ringsWidth.push(ringWidth)\n            ringsProportion.push(ringProportion)\n          }\n          ringData.push({\n            circleRadius: circleRadius,\n            ringsWidth: ringsWidth,\n            ringsProportion: ringsProportion,\n            linesColor: lineColor\n          })\n        }\n        ringsData.push(ringData)\n      }\n      return ringsData\n    },\n\n    // 将折线图坐标返回 file1计算点的位置\n    getLineData (file1, file2, file3) {\n      const keys1 = Object.keys(file1)\n      const linesPoints = []\n      const max2 = Math.max.apply(null, file2[keys1[0]]) > Math.max.apply(null, file2[keys1[1]]) ? Math.max.apply(null, file2[keys1[0]]) : Math.max.apply(null, file2[keys1[1]])\n      const min2 = Math.min.apply(null, file2[keys1[0]]) < Math.min.apply(null, file2[keys1[1]]) ? Math.min.apply(null, file2[keys1[0]]) : Math.min.apply(null, file2[keys1[1]])\n      for (let j = 0; j < keys1.length; j++) {\n        const max = Math.max.apply(null, file1[keys1[j]])\n        const min = Math.min.apply(null, file1[keys1[j]])\n        const linesPoint = []\n        const months = Object.keys(ringJson[keys1[j]])\n        // console.log(ringJson[keys1[j]][months[0]][0][0][0])\n        for (let i = 0; i < file1[keys1[j]].length; i++) {\n          const x = 50 + i * this.chartConfig.monthRectWidth + i * 5\n          const y = j === 0 ? 80 + (max - file1[keys1[j]][i]) / (max - min) * 160 : 360 + (max - file1[keys1[j]][i]) / (max - min) * 160\n          // const name = file2[keys1[j]][i]\n          const proportion = (file2[keys1[j]][i] - min2) / (max2 - min2)\n          let angle = 0\n          for (let k = 0; k < 5; k++) {\n            if (file2[keys1[j]][i] >= ringJson[keys1[j]][months[i]][k][0][0] && file2[keys1[j]][i] <= ringJson[keys1[j]][months[i]][k][0][1]) {\n              angle = (k + (file2[keys1[j]][i] - ringJson[keys1[j]][months[i]][k][0][0]) / (ringJson[keys1[j]][months[i]][k][0][1] - ringJson[keys1[j]][months[i]][k][0][0]))\n              // angle = (k + (file2[keys1[j]][i] - ringJson[keys1[j]][months[i]][k][0][0]) / (ringJson[keys1[j]][months[i]][k][0][1] - ringJson[keys1[j]][months[i]][k][0][0]) * 0.4 * Math.PI)\n              break\n            }\n          }\n          linesPoint.push({\n            x: x,\n            y: y,\n            // name: name,\n            proportion: proportion,\n            angle: angle\n          })\n        }\n        linesPoints.push(linesPoint)\n      }\n      const keys3 = Object.keys(file3)\n      const key3 = Object.keys(file3[keys3[0]])\n      const ratio = []\n      for (let i = 0; i < key3.length; i++) {\n        ratio.push(file3[keys3[0]][key3[i]][1])\n      }\n      const max = Math.max.apply(null, ratio)\n      const min = Math.min.apply(null, ratio)\n      const linesPoint = []\n      for (let i = 0; i < key3.length; i++) {\n        const x = 50 + i * this.chartConfig.monthRectWidth + i * 5\n        const y = 80 + (max - ratio[i]) / (max - min) * 160\n        const name = file3[keys3[0]][key3[i]][0]\n        let angle = 0\n        for (let k = 0; k < 5; k++) {\n          if (file3[keys3[0]][key3[i]][0] >= ringJson[keys1[0]][key3[i]][k][0][0] && file3[keys3[0]][key3[i]][0] <= ringJson[keys1[0]][key3[i]][k][0][1]) {\n            angle = (k + (file3[keys3[0]][key3[i]][0] - ringJson[keys1[0]][key3[i]][k][0][0]) / (ringJson[keys1[0]][key3[i]][k][0][1] - ringJson[keys1[0]][key3[i]][k][0][0]) * 0.4 * Math.PI)\n            break\n          }\n        }\n        linesPoint.push({\n          x: x,\n          y: y,\n          name: name,\n          angle: angle\n        })\n      }\n      linesPoints.push(linesPoint)\n      return linesPoints\n    },\n\n    // 按钮数据读取\n    getBtnData () {\n      const indName = Object.keys(corrInd)\n      this.chartValue.targetInd = indName[0]\n      const keys = Object.keys(corrInd[indName[0]])\n      for (let i = 0; i < 5; i++) {\n        this.chartValue.correlation[i][0] = corrInd[indName[0]][keys[i]][0]\n        this.chartValue.correlation[i][1] = corrInd[indName[0]][keys[i]][1]\n      }\n    }\n  },\n  mounted () {\n    this.creatLineChart()\n    this.getBtnData()\n  }\n}\n</script>\n\n<style scoped>\n\n.container {\n  width: 1700px;\n  height: 600px;\n  /*border: 2px solid black;*/\n}\n\n.container1 {\n  width: 1700px;\n  height: 150px;\n  /*border: 2px solid black;*/\n}\n\n.top {\n  width: 100%;\n  height: 20%;\n  display: flex;\n  /*border: 1px dashed black;*/\n}\n\n.btn {\n  width: 160px;\n  height: 100%;\n  background: #9DC3E6;\n  margin-left: 40px;\n  border-color: white;\n  font-size: 16px;\n}\n\n.below {\n  width: 100%;\n  height: 60%;\n  display: flex;\n  margin-top: 20px;\n}\n\n.tarInd {\n  width: 80px;\n  height: 60%;\n  margin-top: 35px;\n  background: #366AB9;\n  color: white;\n  font-size: 16px;\n}\n\n.corrBtn {\n  width: 15%;\n  height: 100%;\n  display: flex;\n  margin-left: 40px;\n  /*border: 1px dashed black;*/\n}\n\n.marginDiv {\n  margin-left: 1px;\n  width: 100%;\n}\n\n.text {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.corr {\n  margin-top: 10px;\n  width: 200px;\n  background: #54B435;\n  color: white;\n  border-color: white;\n}\n\n</style>\n"],"mappings":";;;EACOA,KAAK,EAAC;AAAW;gEACpBC,mBAAA,CAAsC;EAAjCC,KAAK,EAAC,MAAM;EAACC,MAAM,EAAC;;oBAAzBC,UAAsC,C;;uBADxCC,mBAAA,CAEM,OAFNC,UAEM,EAAAC,UAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}